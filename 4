"""
                                    Задача. Перегрузка операторов.
Задача "Магические здания":
Для решения этой задачи будем пользоваться решением к предыдущей задаче "Атрибуты и методы объекта".

Необходимо дополнить класс House следующими специальными методами:
__len__(self) - должен возвращать кол-во этажей здания self.number_of_floors.
__str__(self) - должен возвращать строку: "Название: <название>, кол-во этажей: <этажи>".
                                    Задача "Нужно больше этажей":
Для решения этой задачи будем пользоваться решением к предыдущей задаче "Специальные методы класса".

Необходимо дополнить класс House следующими специальными методами:
__eq__(self, other) - должен возвращать True, если количество этажей одинаковое у self и у other.
Методы __lt__(<), __le__(<=), __gt__(>), __ge__(>=), __ne__(!=) должны присутствовать в классе и возвращать результаты сравнения по соответствующим операторам. Как и в методе __eq__ в сравнении участвует кол-во этажей.
__add__(self, value) - увеличивает кол-во этажей на переданное значение value, возвращает сам объект self.
__radd__(self, value), __iadd__(self, value) - работают так же как и __add__ (возвращают результат его вызова).
Остальные методы арифметических операторов, где self - x, other - y:

Следует заметить, что other может быть не только числом, но и вообще любым объектом другого класса.
Для более точной логики работы методов __eq__, __add__  и других методов сравнения и арифметики перед выполняемыми действиями лучше убедиться в принадлежности к типу при помощи функции isinstance:
isinstance(other, int) - other указывает на объект типа int.
isinstance(other, House) - other указывает на объект типа House.
                                            Задача:Задача "История строительства":
Для решения этой задачи будем пользоваться решением к предыдущей задаче "Перегрузка операторов".

В классе House создайте атрибут houses_history = [], который будет хранить названия созданных объектов.

Правильней вписывать здание в историю сразу при создании объекта, тем более можно удобно обращаться к атрибутам класса используя ссылку на сам класс - cls.
Дополните метод __new__ так, чтобы:
Название объекта добавлялось в список cls.houses_history.
Название строения можно взять из args по индексу.

Также переопределите метод __del__(self) в котором будет выводиться строка:
"<название> снесён, но он останется в истории"

Создайте несколько объектов класса House и проверьте работу методов __del__ и __new__, а также значение атрибута houses_history.








"""


class House:  #Создаем класс House
    houses_history = [] #Создаем Атррибут houses_history ( Модуль 5.4)

    def __new__(cls, *args, **kwargs):  # ,*args, **kwargs Создаем метод 5.4
        cls.houses_history.append(args[0])
        return super().__new__(cls)

    def __init__(self, name, number_of_floors): #Модуль 5.3
        self.name = name
        self.number_of_floors = number_of_floors

    def __len__(self): #Cчитаем количтво букв (модуль 5.3)
        return self.number_of_floors

    def __str__(self): #Выводи название (Модуль 5.3)
        return f'Название:{self.name},количество этажей:{self.number_of_floors}'

    def __eq__(self, other):
        if isinstance(other.number_of_floors, int) and (other, House): #Cравнение ( Модуль 5.3)
            return self.number_of_floors == other.number_of_floors

    def __le__(self, other): #Меньше или равно (Модуль 5.3)
        if isinstance(other.number_of_floors, int) and (other, House):
            return self.number_of_floors <= other.number_of_floors

    def __lt__(self, other):
        if isinstance(other.number_of_floors, int) and (other, House): #Меньше
            return self.number_of_floors < other.number_of_floors

    def __gt__(self, other):
        if isinstance(other.number_of_floors, int) and (other, House): #Больше
            return self.number_of_floors > other.number_of_floors

    def __ge__(self, other):
        if isinstance(other.number_of_floors, int) and (other, House): #Больше или равно
            return self.number_of_floors >= other.number_of_floors

    def __ne__(self, other):
        if isinstance(other.number_of_floors, int) and (other, House): #Не равно
            return self.number_of_floors != other.number_of_floors

    def __add__(self, vallue): #Метод __add__() — это магический метод, используемый для определения поведения оператора сложения (+), когда он применяется к объектам класса
        if isinstance(vallue, int):
            self.number_of_floors = self.number_of_floors + vallue
            return self

    def __radd__(self, vallue): #Метод __radd__() дополняет __add__(), определяя поведение оператора сложения, когда левый операнд не имеет метода __add__(), или когда его метод __add__() не знает, как обработать правый операнд.
        if isinstance(vallue, int):
            self.number_of_floors = vallue + self.number_of_floors
            return self

    def __iadd__(self, vallue): #Метод __iadd__ - сложение с присваиванием. Например, x += 42
        if isinstance(vallue, int):
            self.number_of_floors += vallue
            return self

    def __del__(self): #Удаление обьекта
        print(f'{self.name},снесен но останется в истории')


h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)


